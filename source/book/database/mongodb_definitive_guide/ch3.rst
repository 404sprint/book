第三章 创建、更新和删除文档
====================================================================

本章介绍数据库移入/移出数据的基本操作，具体包含如下操作:
 - 向集合添加新文档
 - 从集合里删除文档
 - 更新现有文档
 - 为这些操作选择合适的安全级别和速度


3.1 插入并保存文档
------------------------------------------------------------------

::

    db.foo.insert({'bar':'baz'})

这些操作会给文档自动增加一个"_id"键，然后保存到MongoDB中。

3.1.1 批量插入
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

只接受一个文档数组作为参数::

    db.foo.batchinsert([{'_id':0},{'_id':1}])    

目前最大的消息长度为48MB,大于的会拆分成多个插入请求。

3.1.2 插入校验
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

插入数据时，MongoDB只对数据进行最基本的检查:检查文档的基本结构，如果没有"_id"字段就会增加一个。由于MongoDB只进行最基本的检查，所以插入非法数据很容易。

3.2 删除文档
------------------------------------------------------------------

::

    db.foo.remove()
    >db.mailing.list.remove({'option':true})

**删除速度**    

删除文档通常很快，但是要清空整个集合，使用drop直接删除集合更快。


3.3 更新文档
------------------------------------------------------------------

文档存入数据库以后，就可以使用update方法来更新它了。update有两个参数，一个是查询文档，另一个是修改文档

3.3.1 文档替换
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
最简单的更新就是用一个新文档完全替换匹配的文档，这适用进行大规模模式的迁移情况。

::

    {
        '_id':ObjectId('xxxxx'),
        'name':'job',
        'friends':32,
        'enemies':2
    }

我们希望将friends 和 enemies 字段移到 relationships子文档中::

    var joe = db.users.findOne({'name':'job'});
    joe.relationships = {'friends':joe.friends,'enemies':joe.enemies};
    >joe.username = joe.name
    delete joe.friends;
    delete joe.enemies
    delete joe.name
    db.users.update({'name':'joe'},joe);

一个常见的错误是查询条件匹配到了多个文档，然后更新时由于第二个参数的存在就产生重复的ID。数据库会抛出错误，任何文档都不会更新。

使用 _id  作为查询条件比使用随机字段速度更快。

3.3.2 使用修改器
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通常文档只会有一部分要更新，可以使用原子性的更新修改器，指定对文档中的某些字段进行更新，更新修改器是特殊的键，用来指定复杂的更新操作，比如修改，增加或者删除键。还可以操作数组或者内置文档。

::

    #自增1
    db.site.update({'url':'localhost'},{"$inc":{'views':1}})

    db.users.update({'name','joe'},{'$set':{'title':'set title'}})

::

    "$push"会向已有的数组末尾插入一个元素。
    "$each"子操作符，可以通过一次"$each"操作添加多个值
    db.stock.ticker.update({'_id':xxxx},{
        {'$push':{'hourly':{"$each":[1,2,3,4,5]}}}
    })


如果希望数组最大长度是固定的，那么可以将"$slice"和"$push"组合在一起使用，这样就可以确保数组不会超出设定好的长度::

    db.movies.find({'grnre':'hroor'},
    {
    "$push":{'top10':{
    '$each':['nightmare','saw'],"$slice":-10
    }}
    })

这个例子会限制数组只包含最后加入的10个元素，"$slice"必须是负整数。

还有 "$sort","$ne","$addToSet"详细需要用了在查询。

对应删除元素::

    "$pop","$pull"

定位符操作: "$"

移动文档是非常慢的

3.3.3 upsert

upsert是一种特殊的更新。要是没有找到符合更新条件的文档，他会以这个条件和更新文档为基础创建一个新的文档。如果找到文档则更新。supert非常方便，不必预置集合。

3.3.4 更新多个文档
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

默认情况下，更新只对符合条件的第一个文档执行操作，要是有多个文档符合条件，只有第一个文档被更新，需要更新所有文档可以将update的第四个参数设置为true。

3.3.5 返回被更新的文档
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

略



3.4 写入安全机制
------------------------------------------------------------------

略




.. include:: ../../../ad.rst