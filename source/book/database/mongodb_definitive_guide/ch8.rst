第八章 应用程序设计
====================================================================


本章介绍如何设计应用程序，以便更好地使用MongoDB，内容包括：
 - 内嵌数据和引用数据之间的权衡
 - 优化技巧
 - 数据一致性
 - 模式迁移
 - 不合适使用MongoDB作为数据存储的场景

8.1 范式化和反范式化
------------------------------------------------------------------

数据表示的方式有很多种，其中最重要的问题之一就是在大多程度上对数据进行范式化，范式化是将数据分散到多个不同的集合，不同集合之间可以相互引用数据。虽然很多外地可以应用某一块数据，但是这块数据只存储在一个集合中，所以如果要修改这块数据，只需修改保存在这块数据的那一个文档就行了。但是，MongoDB没有提供连接join工具，所以在不同集合之间执行连接查询需要进行多次查询。

反范式化与范式化相反：将每个文档所需的数据都嵌入在文档内部。没文档都拥有自己的数据副本，而不是所有文档共同引用同一个数据副本。这意味着，如果信息发生了改变，那么所有相关文档都需要进行更新，但是执行查询时，只需要一次查询，就可以得到所有数据。


8.1.1 数据表示的例子
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

内容略

.. list-table:: 内嵌数据与引用数据的比较
   :header-rows: 1

   * - 更合适内嵌
     - 更合适引用
   * - 子文档较小
     - 子文档较大
   * - 数据不会定期改变
     - 数据经常改变
   * - 最终数据一致即可
     - 中间阶段的数据必须一致
   * - 文档数据小幅增加
     - 文档数据大幅增加
   * - 数据通常需要执行二次查询才能获得
     - 数据通常不包含在结果中
   * - 快速读取
     - 快速写入

8.1.2 基数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

一个集合中包含的对其他集合的引用数量叫作基数，常见的关系有一对一、一对多、多对多。

8.1.3 还有、粉丝、以及其他的麻烦事项
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

略












.. include:: ../../../ad.rst