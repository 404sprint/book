第八章、字符输入/输出和输入验证
====================================================================


.. Note::

    本章介绍以下内容：
     - 更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别
     - 如果通过键盘模拟文件结尾条件
     - 如何使用重定向把程序和文件相连接
     - 创建更友好的用户界面

最初，输入输出函数不是C定义的一部分，C把开发这些函数的任务留给编译器的实现者来完成。

8.1、单字符IO：getchar()和putchar()
------------------------------------------------------------------

在第七章中提到过，getchar()和putchar()每次只处理一个字符。，这种方法和合适计算机，而且这是绝大多数文本处理程序所用的核心方法。

::

    #include <stdio.h>
    int main(void){
        char ch;
        while((ch = getchar())!='#')
            putchar(ch);
    }


自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联。这就是为什么程序中要包含这个头文件的原因

8.2、缓冲区
------------------------------------------------------------------

缓冲区分为两类：完全缓冲和行缓冲，完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区，通常出现在文件输入中。缓冲区的大小取决于系统，行缓冲指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲，所以在按下Enter键后才刷新缓冲区。

8.3、结束键盘输入
------------------------------------------------------------------

8.3.1、文件、流和键盘输入
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

略


8.3.2、文件结尾
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

无论操作系统实际使用何种方法检测文件结尾，在C语言中用getchar()读取文件检测到文件结尾是将返回一个特殊的值。即EOF。scanf()函数检测到文件结尾时也返回EOF，通常EOF定义在stdio.h文件中::

    #define EOF(-1)

为什么是-1呢，因为getchar()函数的返回值通常都介于0-127之间这些值对应标准字符集，但是如果系统能识别扩展字符，该函数的返回值可能在0-255之间，无卵那种情况，-1都对应不带任何字符，所以该值用于标记文件结尾。

绝大部分系统都有办法通过键盘模拟文件结尾条件::

    while((ch = getchar()) != EOF)    

注意一下几点:
 - 不用定义EOF，因为stdio.h中已经定义过了。
 - 不用担心EOF的实际值，
 - 变量ch的类型从char变为int，因为char类型的变量只能表示0-255的无符号整数，但是EOF的值是-1
 - 由于getchar()函数的返回值类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器就会警告可能丢失数据。
 - 使用该程序进行键盘输入，要设法输入EOF字符，不能只输入EOF，也不能只输入-1

 未完 待更新2018-10-09    












.. include:: ../../../ad.rst 




