第十二章：关注者
==============================

社交 Web 程序允许用户之间相互联系。在程序中,这种关系称为关注者、好友、联系人、 联络人或伙伴。但不管使用哪个名字,其功能都是一样的,而且都要记录两个用户之间的 定向联系,在数据库查询中也要使用这种联系。

在本章,你将学到如何在 Flasky 中实现关注功能,让用户“关注”其他用户,并在首页只 显示所关注用户发布的博客文章列表。

再论数据库关系
------------------------------------------------------------------

我们在第 5 章介绍过,数据库使用关系建立记录之间的联系。其中,一对多关系是最常用的 关系类型,它把一个记录和一组相关的记录联系在一起。实现这种关系时,要在“多”这一 侧加入一个外键,指向“一”这一侧联接的记录。本书开发的示例程序现在包含两个一对多 关系:一个把用户角色和一组用户联系起来,另一个把用户和发布的博客文章联系起来。

大部分的其他关系类型都可以从一对多类型中衍生。多对一关系从“多”这一侧看,就是 一对多关系。一对一关系类型是简化版的一对多关系,限制“多”这一侧最多只能有一个 记录。唯一不能从一对多关系中简单演化出来的类型是多对多关系,这种关系的两侧都有 多个记录。下一节将详细介绍多对多关系。

多对多关系
------------------------------------------------------------------


**这一章很重要数据库的多对多原理 博主经常搞错**
一对多关系、多对一关系和一对一关系至少都有一侧是单个实体,所以记录之间的联系通
过外键实现,让外键指向这个实体。但是,你要如何实现两侧都是“多”的关系呢?

下面以一个典型的多对多关系为例,即一个记录学生和他们所选课程的数据库。很显然, 你不能在学生表中加入一个指向课程的外键,因为一个学生可以选择多个课程,一个外键 不够用。同样,你也不能在课程表中加入一个指向学生的外键,因为一个课程有多个学生 选择。两侧都需要一组外键。

这种问题的解决方法是添加第三张表,这个表称为关联表。现在,多对多关系可以分解成 原表和关联表之间的两个一对多关系。

查询多对多关系要分成两步。若想知道某位学生选择了哪些课程,你要先从学生和注册之 间的一对多关系开始,获取这位学生在 registrations 表中的所有记录,然后再按照多到 一的方向遍历课程和注册之间的一对多关系,找到这位学生在 registrations 表中各记录 所对应的课程。同样,若想找到选择了某门课程的所有学生,你要先从课程表中开始,获 取其在 registrations 表中的记录,再获取这些记录联接的学生。

通过遍历两个关系来获取查询结果的做法听起来有难度,不过像前例这种简单关系, SQLAlchemy 就可以完成大部分操作。

 .. literalinclude:: code/code12-1.py
    :language: python

多对多关系仍使用定义一对多关系的 db.relationship() 方法进行定义,但在多对多关系中, 必须把 secondary 参数设为关联表。多对多关系可以在任何一个类中定义,backref 参数会处 理好关系的另一侧。关联表就是一个简单的表,不是模型,SQLAlchemy 会自动接管这个表。

classes 关系使用列表语义,这样处理多对多关系特别简单。假设学生是 s,课程是 c,学 生注册课程的代码为::

    >>> s.classes.append(c)
    >>> db.session.add(s)

Class 模型中的 students 关系由参数 db.backref() 定义。注意,这个关系中还指定了 lazy= 'dynamic'参数,所以关系两侧返回的查询都可接受额外的过滤器。

如果后来学生 s 决定不选课程 c 了,那么可使用下面的代码更新数据库::

    >>> s.classes.remove(c)

自引用关系
------------------------------------------------------------------

多对多关系可用于实现用户之间的关注,但存在一个问题。在学生和课程的例子中,关联 表联接的是两个明确的实体。但是,表示用户关注其他用户时,只有用户一个实体,没有 第二个实体。

如果关系中的两侧都在同一个表中,这种关系称为自引用关系。在关注中,关系的左侧是 用户实体,可以称为“关注者”;关系的右侧也是用户实体,但这些是“被关注者”。从概 念上来看,自引用关系和普通关系没什么区别,只是不易理解。

高级多对多关系
------------------------------------------------------------------

使用前一节介绍的自引用多对多关系可在数据库中表示用户之间的关注,但却有个限制。 使用多对多关系时,往往需要存储所联两个实体之间的额外信息。对用户之间的关注来 说,可以存储用户关注另一个用户的日期,这样就能按照时间顺序列出所有关注者。这种 信息只能存储在关联表中,但是在之前实现的学生和课程之间的关系中,关联表完全是由 SQLAlchemy 掌控的内部表。

为了能在关系中处理自定义的数据,我们必须提升关联表的地位,使其变成程序可访问的 模型。

app/models/user.py:关注关联表的模型实现::

    class Follow(db.Model):
        __tablename__ = 'follows'
        follower_id = db.Column(db.Integer,db.ForeignKey('users.id'),
            primary_key=True)
        followed_id = db.Column(db.Integer, db.ForeignKey('users.id'),primary_key=True)
        timestamp = db.Column(db.DateTime, default=datetime.utcnow)

SQLAlchemy 不能直接使用这个关联表,因为如果这么做程序就无法访问其中的自定义字 段。相反地,要把这个多对多关系的左右两侧拆分成两个基本的一对多关系,而且要定义 成标准的关系。

app/models/user.py:使用两个一对多关系实现的多对多关系::

    class User(UserMixin, db.Model):
        # ...
        followed = db.relationship('Follow',
            foreign_keys=[Follow.follower_id],
            backref=db.backref('follower', lazy='joined'),
            lazy='dynamic',
            cascade='all, delete-orphan')

        followers = db.relationship('Follow',
            foreign_keys=[Follow.followed_id],
            backref=db.backref('followed', lazy='joined'),
            lazy='dynamic',cascade='all, delete-orphan')


在这段代码中,followed 和 followers 关系都定义为单独的一对多关系。注意,为了 消除外键间的歧义,定义关系时必须使用可选参数 foreign_keys 指定的外键。而且, db.backref() 参数并不是指定这两个关系之间的引用关系,而是回引 Follow 模型。

回引中的 lazy 参数指定为 joined。这个 lazy 模式可以实现立即从联结查询中加载相关对 象。例如,如果某个用户关注了 100 个用户,调用 user.followed.all() 后会返回一个列 表,其中包含 100 个 Follow 实例,每一个实例的 follower 和 followed 回引属性都指向相 应的用户。设定为 lazy='joined' 模式,就可在一次数据库查询中完成这些操作。如果把 lazy 设为默认值 select,那么首次访问 follower 和 followed 属性时才会加载对应的用户, 而且每个属性都需要一个单独的查询,这就意味着获取全部被关注用户时需要增加 100 次 额外的数据库查询。

这两个关系中,User 一侧设定的 lazy 参数作用不一样。lazy 参数都在“一”这一侧设定, 返回的结果是“多”这一侧中的记录。上述代码使用的是 dynamic,因此关系属性不会直 接返回记录,而是返回查询对象,所以在执行查询之前还可以添加额外的过滤器。

cascade 参数配置在父对象上执行的操作对相关对象的影响。比如,层叠选项可设定为: 将用户添加到数据库会话后,要自动把所有关系的对象都添加到会话中。层叠选项的默认 值能满足大多数情况的需求,但对这个多对多关系来说却不合用。删除对象时,默认的层 叠行为是把对象联接的所有相关对象的外键设为空值。但在关联表中,删除记录后正确的 行为应该是把指向该记录的实体也删除,因为这样能有效销毁联接。这就是层叠选项值 delete-orphan 的作用。

cascade 参数的值是一组由逗号分隔的层叠选项,这看起来可能让人有 点困惑,但 all 表示除了 delete-orphan 之外的所有层叠选项。设为 all, delete-orphan 的意思是启用所有默认层叠选项,而且还要删除孤儿记录。

程序现在要处理两个一对多关系,以便实现多对多关系。由于这些操作经常需要重复执 行,所以最好在 User 模型中为所有可能的操作定义辅助方法。

app/models.py:关注关系的辅助方法

 .. literalinclude:: code/code12-2.py
    :language: python

follow() 方法手动把 Follow 实例插入关联表,从而把关注者和被关注者联接起来,并让程 序有机会设定自定义字段的值。联接在一起的两个用户被手动传入 Follow 类的构造器,创 建一个 Follow 新实例,然后像往常一样,把这个实例对象添加到数据库会话中。注意, 这里无需手动设定 timestamp 字段,因为定义字段时指定了默认值,即当前日期和时间。 unfollow() 方法使用 followed 关系找到联接用户和被关注用户的 Follow 实例。若要销毁这 两个用户之间的联接,只需删除这个 Follow 对象即可。is_following() 方法和 is_followed_by() 方法分别在左右两边的一对多关系中搜索指定用户,如果找到了就返回 True。

在资料页中显示关注者
------------------------------------------------------------------

如果用户查看一个尚未关注用户的资料页,页面中要显示一个“Follow”(关注)按钮,如 果查看已关注用户的资料页则显示“Unfollow”(取消关注)按钮。而且,页面中最好能显 示出关注者和被关注者的数量,再列出关注和被关注的用户列表,并在相应的用户资料页 中显示“Follows You”(关注了你)标志。

app/templates/user.html:在用户资料页上部添加关注信息

 .. literalinclude:: code/code12-3.html
    :language: html

这次修改模板用到了 4 个新端点。用户在其他用户的资料页中点击“Follow”(关注)按钮
后,执行的是/follow〈/ username〉路由。

app/main/views.py:“关注”路由和视图函数

 .. literalinclude:: code/code12-4.py
    :language: py

这个视图函数先加载请求的用户,确保用户存在且当前登录用户还没有关注这个用户,然后调用 User 模型中定义的辅助方法 follow(),用以联接两个用户。/unfollow/<username> 路由的实现方式类似。

用户在其他用户的资料页中点击关注者数量后,将调用 /followers/<username> 路由。

app/main/views.py:“关注者”路由和视图函数

 .. literalinclude:: code/code12-5.py
    :language: python

这个函数加载并验证请求的用户,然后使用第 11 章中介绍的技术分页显示该用户的 followers 关系。由于查询关注者返回的是 Follow 实例列表,为了渲染方便,我们将其转 换成一个新列表,列表中的各元素都包含 user 和 timestamp 字段。

渲染关注者列表的模板可以写的通用一些,以便能用来渲染关注的用户列表和被关注的用 户列表。模板接收的参数包括用户对象、分页链接使用的端点、分页对象和查询结果列表。

followed_by 端点的实现过程几乎一样,唯一区别在于:用户列表从 user.followed 关系中 获取。传入模板的参数也要进行相应调整。

followers.html 模板使用两列表格实现,左边一列用于显示用户名和头像,右边一列用于显 示 Flask-Moment 时间戳。

使用数据库联结查询所关注用户的文章
------------------------------------------------------------------

程序首页目前按时间降序显示数据库中的所有文章。现在我们已经完成了关注功能,如果能让用户选择只查看所关注用户发布的博客文章就更好了。

若想显示所关注用户发布的所有文章,第一步显然先要获取这些用户,然后获取各用户的 文章,再按一定顺序排列,写入单独列表。可是这种方式的伸缩性不好,随着数据库不断 变大,生成这个列表的工作量也不断增长,而且分页等操作也无法高效率完成。获取博客 文章的高效方式是只用一次查询。

完成这个操作的数据库操作称为联结。联结操作用到两个或更多的数据表,在其中查找满 足指定条件的记录组合,再把记录组合插入一个临时表中,这个临时表就是联结查询的结 果。理解联结查询的最好方法是实例讲解。


下面略，查询的语句

在首页显示所关注用户的文章
------------------------------------------------------------------

现在,用户可以选择在首页显示所有用户的博客文章还是只显示所关注用户的文章了。

app/main/views.py:显示所有博客文章或只显示所关注用户的文章

 .. literalinclude:: code/code12-6.py
    :language: python

决定显示所有博客文章还是只显示所关注用户文章的选项存储在 cookie 的 show_followed 字段中,如果其值为非空字符串,则表示只显示所关注用户的文章。cookie 以 request. cookies 字典的形式存储在请求对象中。这个 cookie 的值会转换成布尔值,根据得到的值 设定本地变量 query 的值。query 的值决定最终获取所有博客文章的查询,或是获取过滤 后的博客文章查询。显示所有用户的文章时,要使用顶级查询 Post.query;如果限制只 显示所关注用户的文章,要使用最近添加的 User.followed_posts 属性。然后将本地变量 query 中保存的查询进行分页,像往常一样将其传入模板。

show_followedcookie 在两个新路由中设定

app/main/views.py:查询所有文章还是所关注用户的文章

 .. literalinclude:: code/code12-7.py
    :language: python

指向这两个路由的链接添加在首页模板中。点击这两个链接后会为 show_followedcookie 设 定适当的值,然后重定向到首页。

cookie 只能在响应对象中设置,因此这两个路由不能依赖 Flask,要使用 make_response() 方法创建响应对象。

set_cookie() 函数的前两个参数分别是 cookie 名和值。可选的 max_age 参数设置 cookie 的 过期时间,单位为秒。如果不指定参数 max_age,浏览器关闭后 cookie 就会过期。在本例 中,过期时间为 30 天,所以即便用户几天不访问程序,浏览器也会记住设定的值。

如果你现在访问网站,切换到所关注用户文章列表,会发现自己的文章不在列表中。这是 肯定的,因为用户不能关注自己。

虽然查询能按设计正常执行,但用户查看好友文章时还是希望能看到自己的文章。这个问 题最简单的解决办法是,注册时把用户设为自己的关注者。

app/models.py:构建用户时把用户设为自己的关注者::

    class User(UserMixin, db.Model):
        # ...
        def __init__(self, **kwargs):
            # ...
            self.follow(self)

可是,现在的数据库中可能已经创建了一些用户,而且都没有关注自己。如果数据库还比 较小,容易重新生成,那么可以删掉再重新创建。


app/models.py:把用户设为自己的关注者::

    class User(UserMixin, db.Model):
        # ...
        @staticmethod
        def add_self_follows():
            for user in User.query.all():
                if not user.is_following(user):
                    user.follow(user)
                    db.session.add(user)
                    db.session.commit()
        # ...

现在,可以通过在 shell 中运行这个函数来更新数据库::
    
    (venv) $ python manage.py shell
    >>> User.add_self_follows()

 .. literalinclude:: code/code9-1.py
    :language: python

创建函数更新数据库这一技术经常用来更新已部署的程序,因为运行脚本更新比手动更新 数据库更少出错。

用户关注自己这一功能的实现让程序变得更实用,但也有一些副作用。因为用户的自关注 链接,用户资料页显示的关注者和被关注者的数量都增加了 1 个。为了显示准确,这些数 字要减去1,这一点在模板中很容易实现,直接渲染{{ user.followers.count() - 1 }}和 {{ user.followed.count() - 1 }} 即可。然后,还要调整关注用户和被关注用户的列表,不显示自己。这在模板中也容易实现,使用条件语句即可。最后,检查关注者数量的单元 测试也会受到自关注的影响,必须做出调整,计入自关注。


.. include:: ../../../ad.rst  