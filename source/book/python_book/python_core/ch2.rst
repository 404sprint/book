第二章：网络编程
=====================

在本节中,我们将简要的介绍如何使用套接字进行网络编程。首先,我们将给出一些网络编程 方面的背景资料和 Python 中使用套接字的方法,然后介绍如何使用 Python 的一些模块来创建网络 化的应用程序。

什么是客户/服务器架构?
------------------------------------------------------------------

什么是客户/服务器架构?不同的人有不同的答案。这要看你问的是什么人,以及指的是软件 系统还是硬件系统了。但是,有一点是共通的:服务器是一个软件或硬件,用于提供客户需要的“服 务”。服务器存在的唯一目的就是等待客户的请求,给这些客户服务,然后再等待其它的请求。

另一方面,客户连上一个(预先已知的)服务器,提出自己的请求,发送必要的数据,然后就 等待服务器的完成请求或说明失败原因的反馈。服务器不停地处理外来的请求,而客户一次只能提 出一个服务的请求,等待结果。然后结束这个事务。客户之后也可以再提出其它的请求,只是,这 个请求会被视为另一个不同的事务了。

**硬件的客户/服务器架构**

打印(机)服务是一个硬件服务器的例子。它们处理打印任务,并把任务发给相连的打印机(或 其它打印设备)。这样的电脑一般是可以通过网络访问并且客户机器可以远程发送打印请求给它。

另一个硬件服务器的例子是文件服务器。它们一般拥有大量的存储空间,客户可以远程访问。
客户机器可以把服务器的磁盘映射到自己本地,就像本地磁盘一样使用它们。其中, SunMicrosystems 公司的 Network File System(NFS)是使用最广泛的网络文件系统之一。如果你正 在访问网络磁盘,并且区分不出是本地的还是网络上的,那客户/服务器系统就很好的完成了它们 的工作。其目的就是要让用户使用起来感觉就像使用本地磁盘一样。“抽象”到一般的磁盘访问这一 层上后,所有的操作都是一样的,而让所有操作都一样的“实现”则要依靠各自的程序了。

**软件客户/服务器架构**

软件服务器也是运行在某个硬件上的。但不像硬件服务器那样,有专门的设备,如打印机,磁盘等。软件服务器提供的服务主要是程序的运行,数据的发送与接收,合并,升级或其它的程序或数据的操作。

如今,最常用的软件服务器是 Web 服务器。一台机器里放一些网页或 Web 应用程序,然后启动 服务。这样的服务器的任务就是接受客户的请求,把网页发给客户(如用户计算机上的浏览器),然 后等待下一个客户请求。这些服务启动后的目标就是“永远运行下去”。虽然它们不可能实现这样的 目标,但只要没有关机或硬件出错等外力干扰,它们就能运行非常长的一段时间。


数据库服务器是另一种软件服务器。它们接受客户的保存或读取请求,完成请求,然后再等待 其它的请求。它们也被设计为要能“永远”运行。


我们要讨论的最后一种软件服务器是窗口服务器。这些服务器几乎可以认为是硬件服务器。它 们运行于一个有显示器的机器上。窗口的客户是那些在运行时需要窗口环境的程序,它们一般会被 叫做图形界面(GUI)程序。在一个 DOS 窗口或 Unix 的 shell 中等没有窗口服务器的环境中,它们将 无法启动。一旦窗口服务器可以使用时,那一切就正常了。


当世界有了网络,那这样的环境就开始变得更有趣了。一般情况下,窗口客户的显示和窗口服 务器的提供都在同一台电脑上。但在 X Window 之类的网络化的窗口环境中,你可以选
择其它电脑的窗口服务器来做显示即你可以在一台电脑上运行 GUI 程序,而在另一台电脑上显 示它!

**客户/服务器网络编程**

什么是套接字?
------------------------------------------------------------------

套接字是一种具有之前所说的“通讯端点”概念的计算机网络数据结构。网络化的应用程序在
 开始任何通讯之前都必需要创建套接字。就像电话的插口一样,没有它就完全没办法通讯。

套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种,分别是基于文 件型的和基于网络型的。

Unix 套接字是我们要介绍的第一个套接字家族。其“家族名”为 AF_UNIX(在 POSIX1.g 标准中 也叫 AF_LOCAL),表示“地址家族:UNIX”。包括 Python 在内的大多数流行平台上都使用术语“地址 家族”及其缩写“AF”。而老一点的系统中,地址家族被称为“域”或“协议家族”,并使用缩写“PF” 而不是“AF”。同样的,AF_LOCAL(在 2000-2001 年被列为标准)将会代替 AF_UNIX。不过,为了向后 兼容,很多系统上,两者是等价的。Python 自己则仍然使用 AF_UNIX。


由于两个进程都运行在同一台机器上,而且这些套接字是基于文件的。所以,它们的底层结构 是由文件系统来支持的。这样做相当有道理,因为,同一台电脑上,文件系统的确是不同的进程都 能访问的。


Python 只支持 AF_UNIX,AF_NETLINK,和 AF_INET 家族。由于我们只关心网络编程,所以在本 章的大部分时候,我们都只用 AF_INET。


套接字地址:主机与端口
------------------------------------------------------------------

如果把套接字比做电话的插口——即通讯的最底层结构,那主机与端口就像区号与电话号码的 一对组合。有了能打电话的硬件还不够,你还要知道你要打给谁,往哪打。一个 Internet 地址由网 络通讯所必需的主机与端口组成。而且不用说,另一端一定要有人在听才可以。否则,你就会听到 熟悉的声音“对不起,您拨的是空号,请查对后再播”。你在上网的时候,可能也见过类似的情况, 如“不能连接该服务器。服务器无响应或不可达”。



合法的端口号范围为 0 到 65535。其中,小于 1024 的端口号为系统保留端口。如果你所使用的 是 Unix 操作系统,保留的端口号(及其对应的服务/协议和套接字类型)可以通过/etc/services 文件获得。常用端口号列表可以从下面这个网站获得:
http://www.iana.org/assignments/port-numbers

Python 中的网络编程
------------------------------------------------------------------

现在,你已经有了足够的客户/服务器,套接字和网络方面的知识。我们现在就开始把这些概 念带到 Python 中来。本节中,我们将主要使用 socket 模块。模块中的 socket()函数被用来创建套 接字。套接字也有自己的一套函数来提供基于套接字的网络通讯。


socket()模块函数
------------------------------------------------------------------

要使用 socket.socket()函数来创建套接字。其语法如下::
    
    socket(socket_family, socket_type, protocol=0)

socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。 这几个常量的意义可以参考之前的解释。protocol 一般不填,默认值为 0。

创建一个 TCP/IP 的套接字,你要这样调用 socket.socket()::
    
    tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

同样地,创建一个 UDP/IP 的套接字,你要这样::

    udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)



由于 socket 模块中有太多的属性。我们在这里破例使用了'from module import \*'语句。使用 'from socket import \*',我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。

::

    tcpSock = socket(AF_INET, SOCK_STREAM)

当我们创建了套接字对象后,所有的交互都将通过对该套接字对象的方法调用进行。

套接字对象(内建)方法
------------------------------------------------------------------

我们列出了最常用的套接字对象的方法。在下一个小节中,我们将分别创建 TCP 和 UDP 的客户和服务器,它们都要用到这些方法。虽然我们只关心 Internet 套接字,但是这些方法在 Unix 套接字中的也有类似的意义。















.. include:: ../../../ad.rst