

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第十四章：应用编程接口 &mdash; my_book_doc  文档</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="第十五章：测试" href="ch15.html" />
    <link rel="prev" title="第十三章：用户评论" href="ch13.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> my_book_doc
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../python_book.html">python相关书籍</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../python_book.html#id1">python</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../python_book.html#web">web开发</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../python_web_development.html">python web开发实战—董伟明</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../flask_web_development.html">Flask Web开发(狗书)</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="ch1.html">第一章：安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch2.html">第二章：程序基本结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch3.html">第三章：模板</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch4.html">第四章：web表单</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch5.html">第五章：数据库</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch6.html">第六章：电子邮件</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch7.html">第七章：大型程序的结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch8.html">第八章：用户认证</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch9.html">第九章：用户角色</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch10.html">第十章：用户资料</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch11.html">第十一章：博客文章</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch12.html">第十二章：关注者</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch13.html">第十三章：用户评论</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">第十四章：应用编程接口</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch15.html">第十五章：测试</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch16.html">第十六章：性能</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch17.html">第十七章：部署</a></li>
<li class="toctree-l4"><a class="reference internal" href="ch18.html">第十八章：其他资源</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../python_book.html#wxpython-qt">客户端开发(wxpython/qt)</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../security_book.html">安全相关书籍</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../asm_c_cjj_book.html">ASM/C/C++书籍</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../algorithm.html">算法相关书籍</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../database.html">数据库相关书籍</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ai.html">人工智能相关书籍</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mathematics.html">数学书</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../note/othor.html">笔记</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">my_book_doc</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../python_book.html">python相关书籍</a> &raquo;</li>
        
          <li><a href="../flask_web_development.html">Flask Web开发(狗书)</a> &raquo;</li>
        
      <li>第十四章：应用编程接口</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>第十四章：应用编程接口<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>最近几年,Web 程序有种趋势,那就是业务逻辑被越来越多地移到了客户端一侧,开创出 了一种称为富互联网应用(Rich Internet Application,RIA)的架构。在RIA中,服务器的 主要功能(有时是唯一功能)是为客户端提供数据存取服务。在这种模式中,服务器变成 了 Web 服务或应用编程接口(Application Programming Interface,API)。</p>
<p>RIA可采用多种协议与Web服务通信。远程过程调用(Remote Procedure Call,RPC)协议, 例如 XML-RPC,及由其衍生的简单对象访问协议(Simplified Object Access Protocol,SOAP), 在几年前比较受欢迎。最近,表现层状态转移(Representational State Transfer,REST)架构崭 露头角,成为 Web 程序的新宠,因为这种架构建立在大家熟识的万维网基础之上。</p>
<p>Flask 是开发 REST 架构 Web 服务的理想框架,因为 Flask 天生轻量。在本章,你将学到 如何使用 Flask 实现符合 REST 架构的 API。</p>
<div class="section" id="rest">
<h2>REST简介<a class="headerlink" href="#rest" title="永久链接至标题">¶</a></h2>
<p>Roy Fielding在其博士论文(<a class="reference external" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style</a>.
htm)中介绍了 Web 服务的 REST 架构方式,并列出了 6 个符合这一架构定义的特征。</p>
<dl class="docutils">
<dt>客户端−服务器:</dt>
<dd>客户端和服务器之间必须有明确的界线。</dd>
<dt>无状态</dt>
<dd>客户端发出的请求中必须包含所有必要的信息。服务器不能在两次请求之间保存客户端的任何状态。</dd>
<dt>缓存</dt>
<dd>服务器发出的响应可以标记为可缓存或不可缓存,这样出于优化目的,客户端(或客户端和服务器之间的中间服务)可以使用缓存。</dd>
<dt>接口统一</dt>
<dd>客户端访问服务器资源时使用的协议必须一致,定义良好,且已经标准化。REST Web 服务最常使用的统一接口是 HTTP 协议。</dd>
<dt>系统分层</dt>
<dd>在客户端和服务器之间可以按需插入代理服务器、缓存或网关,以提高性能、稳定性和伸缩性。</dd>
<dt>按需代码</dt>
<dd>客户端可以选择从服务器上下载代码,在客户端的环境中执行。</dd>
</dl>
</div>
<div class="section" id="id2">
<h2>资源就是一切<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>资源是 REST 架构方式的核心概念。在 REST 架构中,资源是程序中你要着重关注的事物。
例如,在博客程序中,用户、博客文章和评论都是资源。</p>
<p>每个资源都要使用唯一的URL表示。还是以博客程序为例,一篇博客文章可以使用URL / api/posts/12345 表示,其中 12345 是这篇文章的唯一标识符,使用文章在数据库中的主键 表示。URL 的格式或内容无关紧要,只要资源的 URL 只表示唯一的一个资源即可。</p>
<p>某一类资源的集合也要有一个 URL。博客文章集合的 URL 可以是 /api/posts/,评论集合的 URL 可以是 /api/comments/。</p>
<p>API 还可以为某一类资源的逻辑子集定义集合 URL。例如,编号为 12345 的博客文章,其 中的所有评论可以使用URL /api/posts/12345/comments/表示。表示资源集合的URL习惯 在末端加上一个斜线,代表一种“文件夹”结构。</p>
<p>注意,Flask 会特殊对待末端带有斜线的路由。如果客户端请求的 URL 的末 端没有斜线,而唯一匹配的路由末端有斜线,Flask 会自动响应一个重定向, 转向末端带斜线的 URL。反之则不会重定向。</p>
</div>
<div class="section" id="id3">
<h2>请求方法<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>客户端程序在建立起的资源 URL 上发送请求,使用请求方法表示期望的操作。若要从博客 API 中获取现有博客文章的列表,客户端可以向 <a class="reference external" href="http://www.exam-ple.com/api/posts/">http://www.exam-ple.com/api/posts/</a> 发 送 GET 请求。若要插入一篇新博客文章,客户端可以向同一地址发送 POST 请求,而且请求 主体中要包含博客文章的内容。若要获取编号为 12345 的博客文章,客户端可以向 <a class="reference external" href="http://">http://</a> www.example.com/api/posts/12345 发送 GET 请求。</p>
</div>
<div class="section" id="id4">
<h2>请求和响应主体<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>在请求和响应的主体中,资源在客户端和服务器之间来回传送,但 REST 没有指定编码 资源的方式。请求和响应中的 Content-Type 首部用于指明主体中资源的编码方式。使用 HTTP 协议中的内容协商机制,可以找到一种客户端和服务器都支持的编码方式。</p>
<p>REST Web服务常用的两种编码方式是JavaScript对象表示法(JavaScript Object Notation, JSON)和可扩展标记语言(Extensible Markup Language,XML)。对基于Web的RIA来 说,JSON 更具吸引力,因为 JSON 和 JavaScript 联系紧密,而 JavaScript 是 Web 浏览器 使用的客户端脚本语言。继续以博客 API 为例,一篇博客文章对应的资源可以使用如下的 JSON 表示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://www.example.com/api/posts/12345&quot;</span><span class="p">,</span>
    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Writing RESTful APIs in Python&quot;</span><span class="p">,</span>
    <span class="s2">&quot;author&quot;</span><span class="p">:</span> <span class="s2">&quot;http://www.example.com/api/users/2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;body&quot;</span><span class="p">:</span> <span class="s2">&quot;... text of the article here ...&quot;</span><span class="p">,</span>
    <span class="s2">&quot;comments&quot;</span><span class="p">:</span> <span class="s2">&quot;http://www.example.com/api/posts/12345/comments&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意,在这篇博客文章中,url、author 和 comments 字段都是完整的资源 URL。这是很重 要的表示方法,因为客户端可以通过这些 URL 发掘新资源。</p>
<p>在设计良好的REST API中,客户端只需知道几个顶级资源的URL,其他资源的URL则从响 应中包含的链接上发掘。这就好比浏览网络时,你在自己知道的网页中点击链接发掘新网页。</p>
</div>
<div class="section" id="id5">
<h2>版本<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>在传统的以服务器为中心的 Web 程序中,服务器完全掌控程序。更新程序时,只需在服务 器上部署新版本就可更新所有的用户,因为运行在用户 Web 浏览器中的那部分程序也是从 服务器上下载的。</p>
<p>但升级 RIA 和 Web 服务要复杂得多,因为客户端程序和服务器上的程序是独立开发的, 有时甚至由不同的人进行开发。你可以考虑一下这种情况,即一个程序的REST Web服 务被很多客户端使用,其中包括 Web 浏览器和智能手机原生应用。服务器可以随时更新 Web 浏览器中的客户端,但无法强制更新智能手机中的应用,更新前先要获得机主的许 可。即便机主想进行更新,也不能保证新版应用上传到所有应用商店的时机都完全吻合新 服务器端版本的部署。</p>
<p>基于以上原因,Web 服务的容错能力要比一般的 Web 程序强,而且还要保证旧版客户端 能继续使用。这一问题的常见解决办法是使用版本区分 Web 服务所处理的 URL。例如, 首次发布的博客 Web 服务可以通过 /api/v1.0/posts/ 提供博客文章的集合。</p>
<p>在 URL 中加入 Web 服务的版本有助于条理化管理新旧功能,让服务器能为新客户端提供 新功能,同时继续支持旧版客户端。博客服务可能会修改博客文章使用的 JSON 格式,同 时通过 /api/v1.1/posts/ 提供修改后的博客文章,而客户端仍能通过 /api/v1.0/posts/ 获取旧的 JSON 格式。在一段时间内,服务器要同时处理 v1.1 和 v1.0 这两个版本的 URL。</p>
<p>提供多版本支持会增加服务器的维护负担,但在某些情况下,这是不破坏现有部署且能让 程序不断发展的唯一方式。</p>
</div>
<div class="section" id="flaskrest-web">
<h2>使用Flask提供REST Web服务<a class="headerlink" href="#flaskrest-web" title="永久链接至标题">¶</a></h2>
<p>使用Flask创建REST Web服务很简单。使用熟悉的route()修饰器及其methods可选参 数可以声明服务所提供资源 URL 的路由。处理 JSON 数据同样简单,因为请求中包含的 JSON 数据可通过 request.json 这个 Python 字典获取,并且需要包含 JSON 的响应可以使 用 Flask 提供的辅助函数 jsonify() 从 Python 字典中生成。</p>
<p>以下几节将介绍如何扩展Flasky,创建一个REST Web服务,以便让客户端访问博客文章 及相关资源。
￼
创建API蓝本
——————————————————————</p>
<p>REST API相关的路由是一个自成一体的程序子集,所以为了更好地组织代码,我们最好
把这些路由放到独立的蓝本中。</p>
<p>注意,API 包的名字中有一个版本号。如果需要创建一个向前兼容的 API 版本,可以添加 一个版本号不同的包,让程序同时支持两个版本的 API。</p>
<p>在这个 API 蓝本中,各资源分别在不同的模块中实现。蓝本中还包含处理认证、错误以及 提供自定义修饰器的模块。蓝本的构造文件如示例 14-2 所示。</p>
<p>app/api_1_0/__init__.py:API 蓝本的构造文件:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Blueprint</span>
<span class="n">api</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">(</span><span class="s1">&#39;api&#39;</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">authentication</span><span class="p">,</span> <span class="n">posts</span><span class="p">,</span> <span class="n">users</span><span class="p">,</span> <span class="n">comments</span><span class="p">,</span> <span class="n">errors</span>
</pre></div>
</div>
<p>app/_init_.py:注册 API 蓝本:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_app</span><span class="p">(</span><span class="n">config_name</span><span class="p">):</span>
<span class="c1"># ...</span>
<span class="kn">from</span> <span class="nn">.api_1_0</span> <span class="k">import</span> <span class="n">api</span> <span class="k">as</span> <span class="n">api_1_0_blueprint</span>
<span class="n">app</span><span class="o">.</span><span class="n">register_blueprint</span><span class="p">(</span><span class="n">api_1_0_blueprint</span><span class="p">,</span> <span class="n">url_prefix</span><span class="o">=</span><span class="s1">&#39;/api/v1.0&#39;</span><span class="p">)</span>
<span class="c1"># ...</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>错误处理<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>REST Web服务将请求的状态告知客户端时,会在响应中发送适当的HTTP状态码,并将
额外信息放入响应主体。</p>
<p>处理 404 和 500 状态码时会有点小麻烦,因为这两个错误是由 Flask 自己生成的,而且一 般会返回 HTML 响应,这很可能会让 API 客户端困惑。</p>
<p>为所有客户端生成适当响应的一种方法是,在错误处理程序中根据客户端请求的格式改写 响应,这种技术称为内容协商。示例 14-4 是改进后的 404 错误处理程序,它向 Web 服务 客户端发送 JSON 格式响应,除此之外都发送 HTML 格式响应。500 错误处理程序的写法 类似。</p>
<p>app/main/errors.py:使用 HTTP 内容协商处理错误:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@main</span><span class="o">.</span><span class="n">app_errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">accept_mimetypes</span><span class="o">.</span><span class="n">accept_json</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="n">request</span><span class="o">.</span><span class="n">accept_mimetypes</span><span class="o">.</span><span class="n">accept_html</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">({</span><span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="s1">&#39;not found&#39;</span><span class="p">})</span>
        <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">404</span>
        <span class="k">return</span> <span class="n">response</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;404.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>这个新版错误处理程序检查 Accept 请求首部(Werkzeug 将其解码为 request.accept_mimetypes),根据首部的值决定客户端期望接收的响应格式。浏览器一般不限制响应的格 式,所以只为接受 JSON 格式而不接受 HTML 格式的客户端生成 JSON 格式响应。</p>
<p>其他状态码都由 Web 服务生成,因此可在蓝本的 errors.py 模块作为辅助函数实现。示例 14-5 是 403 错误的处理程序,其他错误处理程序的写法类似。</p>
<p>app/api_1_0/errors.py:API 蓝本中 403 状态码的错误处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">forbidden</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">jsonify</span><span class="p">({</span><span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="s1">&#39;forbidden&#39;</span><span class="p">,</span> <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="n">message</span><span class="p">})</span>
    <span class="n">response</span><span class="o">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="mi">403</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
</div>
</div>
<div class="section" id="flask-http-auth">
<h2>使用Flask-HTTP Auth认证用户<a class="headerlink" href="#flask-http-auth" title="永久链接至标题">¶</a></h2>
<p>和普通的 Web 程序一样,Web 服务也需要保护信息,确保未经授权的用户无法访问。为
此,RIA 必须询问用户的登录密令,并将其传给服务器进行验证。</p>
<p>我们前面说过,REST Web服务的特征之一是无状态,即服务器在两次请求之间不能“记 住”客户端的任何信息。客户端必须在发出的请求中包含所有必要信息,因此所有请求都 必须包含用户密令。</p>
<p>程序当前的登录功能是在 Flask-Login 的帮助下实现的,可以把数据存储在用户会话中。默 认情况下,Flask 把会话保存在客户端 cookie 中,因此服务器没有保存任何用户相关信息, 都转交给客户端保存。这种实现方式看起来遵守了 REST 架构的无状态要求,但在 REST Web 服务中使用 cookie 有点不现实,因为 Web 浏览器之外的客户端很难提供对 cookie 的 支持。鉴于此,使用 cookie 并不是一个很好的设计选择。</p>
<p>REST 架构的无状态要求看起来似乎过于严格,但这并不是随意提出的要 求,无状态的服务器伸缩起来更加简单。如果服务器保存了客户端的相关信 息,就必须提供一个所有服务器都能访问的共享缓存,这样才能保证一直使 用同一台服务器处理特定客户端的请求。这样的需求很难实现。</p>
<p>因为 REST 架构基于 HTTP 协议,所以发送密令的最佳方式是使用 HTTP 认证,基本认证 和摘要认证都可以。在 HTTP 认证中,用户密令包含在请求的 Authorization 首部中。</p>
<p>HTTP认证协议很简单,可以直接实现,不过Flask-HTTPAuth扩展提供了一个便利的包 装,可以把协议的细节隐藏在修饰器之中,类似于 Flask-Login 提供的 login_required 修 饰器。</p>
<p>Flask-HTTPAuth使用pip安装:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ pip install flask-httpauth
</pre></div>
</div>
<p>在将 HTTP 基本认证的扩展进行初始化之前,我们先要创建一个 HTTPBasicAuth 类对象。 和Flask-Login一样,Flask-HTTPAuth不对验证用户密令所需的步骤做任何假设,因此所需的信息在回调函数中提供。示例14-6展示了如何初始化Flask-HTTPAuth扩展,以及如 何在回调函数中验证密令。</p>
<p>app/api_1_0/authentication.py:初始化Flask-HTTPAuth</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask.ext.httpauth</span> <span class="kn">import</span> <span class="n">HTTPBasicAuth</span>

<span class="n">auth</span> <span class="o">=</span> <span class="n">HTTPBasicAuth</span><span class="p">()</span>

<span class="nd">@auth.verify_password</span>
<span class="k">def</span> <span class="nf">verify_password</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">email</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="o">=</span> <span class="n">AnonymousUser</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">email</span> <span class="o">=</span> <span class="n">email</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">user</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="k">return</span> <span class="n">user</span><span class="o">.</span><span class="n">verify_password</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>由于这种用户认证方法只在API蓝本中使用,所以Flask-HTTPAuth扩展只在蓝本包中初 始化,而不像其他扩展那样要在程序包中初始化。</p>
<p>电子邮件和密码使用 User 模型中现有的方法验证。如果登录密令正确,这个验证回调函数 就返回 True,否则返回 False。API 蓝本也支持匿名用户访问,此时客户端发送的电子邮 件字段必须为空。</p>
<p>验证回调函数把通过认证的用户保存在 Flask 的全局对象 g 中,如此一来,视图函数便能 进行访问。注意,匿名登录时,这个函数返回 True 并把 Flask-Login 提供的 AnonymousUser 类实例赋值给 g.current_user。</p>
<p>如果认证密令不正确,服务器向客户端返回401错误。默认情况下,Flask-HTTPAuth自 动生成这个状态码,但为了和 API 返回的其他错误保持一致,我们可以自定义这个错误响 应</p>
<p>app/api_1_0/authentication.py:Flask-HTTPAuth错误处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@auth</span><span class="o">.</span><span class="n">error_handler</span>
<span class="k">def</span> <span class="nf">auth_error</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">unauthorized</span><span class="p">(</span><span class="s1">&#39;Invalid credentials&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>为保护路由,可使用修饰器 auth.login_required:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/posts/&#39;</span><span class="p">)</span>
<span class="nd">@auth</span><span class="o">.</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">get_posts</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>不过,这个蓝本中的所有路由都要使用相同的方式进行保护,所以我们可以在 before_request 处理程序中使用一次 login_required 修饰器,应用到整个蓝本,</p>
<p>app/api_1_0/authentication.py:在 before_request 处理程序中进行认证</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">forbidden_error</span>
<span class="nd">@api</span><span class="o">.</span><span class="n">before_request</span>
<span class="nd">@auth</span><span class="o">.</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">before_request</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span><span class="o">.</span><span class="n">is_anonymous</span> <span class="ow">and</span> \
        <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span><span class="o">.</span><span class="n">confirmed</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">forbidden</span><span class="p">(</span><span class="s1">&#39;Unconfirmed account&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>现在,API 蓝本中的所有路由都能进行自动认证。而且作为附加认证,before_request 处理程序还会拒绝已通过认证但没有确认账户的用户。</p>
</div>
<div class="section" id="id7">
<h2>基于令牌的认证<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>每次请求时,客户端都要发送认证密令。为了避免总是发送敏感信息,我们可以提供一种
基于令牌的认证方案。</p>
<p>使用基于令牌的认证方案时,客户端要先把登录密令发送给一个特殊的 URL,从而生成 认证令牌。一旦客户端获得令牌,就可用令牌代替登录密令认证请求。出于安全考虑,令 牌有过期时间。令牌过期后,客户端必须重新发送登录密令以生成新令牌。令牌落入他人 之手所带来的安全隐患受限于令牌的短暂使用期限。为了生成和验证认证令牌,我们要在 User 模型中定义两个新方法。这两个新方法用到了 itsdangerous 包,</p>
<p>app/models.py:支持基于令牌的认证</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">generate_auth_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expiration</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Serializer</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;SECRET_KEY&#39;</span><span class="p">],</span><span class="n">expires_in</span><span class="o">=</span><span class="n">expiration</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">})</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">verify_auth_token</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Serializer</span><span class="p">(</span><span class="n">current_app</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;SECRET_KEY&#39;</span><span class="p">])</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
<p>generate_auth_token() 方法使用编码后的用户 id 字段值生成一个签名令牌,还指定了以秒 为单位的过期时间。verify_auth_token() 方法接受的参数是一个令牌,如果令牌可用就返 回对应的用户。verify_auth_token() 是静态方法,因为只有解码令牌后才能知道用户是谁。</p>
<p>为了能够认证包含令牌的请求,我们必须修改Flask-HTTPAuth提供的verify_password回 调,除了普通的密令之外,还要接受令牌。</p>
<p>app/api_1_0/authentication.py:支持令牌的改进验证回调</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@auth.verify_password</span>
<span class="k">def</span> <span class="nf">verify_password</span><span class="p">(</span><span class="n">email_or_token</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">email_or_token</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="o">=</span> <span class="n">AnonymousUser</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">password</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">verify_auth_token</span><span class="p">(</span><span class="n">email_or_token</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">token_used</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">email</span><span class="o">=</span><span class="n">email_or_token</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">user</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="o">=</span> <span class="n">user</span>
    <span class="n">g</span><span class="o">.</span><span class="n">token_used</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">user</span><span class="o">.</span><span class="n">verify_password</span><span class="p">(</span><span class="n">password</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>在这个新版本中,第一个认证参数可以是电子邮件地址或认证令牌。如果这个参数为空, 那就和之前一样,假定是匿名用户。如果密码为空,那就假定 email_or_token 参数提供的 是令牌,按照令牌的方式进行认证。如果两个参数都不为空,假定使用常规的邮件地址和 密码进行认证。在这种实现方式中,基于令牌的认证是可选的,由客户端决定是否使用。 为了让视图函数能区分这两种认证方法,我们添加了 g.token_used 变量。</p>
<p>把认证令牌发送给客户端的路由也要添加到 API 蓝本中,</p>
<p>app/api_1_0/authentication.py:生成认证令牌:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/token&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_token</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span><span class="o">.</span><span class="n">is_anonymous</span><span class="p">()</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">token_used</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unauthorized</span><span class="p">(</span><span class="s1">&#39;Invalid credentials&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">({</span><span class="s1">&#39;token&#39;</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span><span class="o">.</span><span class="n">generate_auth_token</span><span class="p">(</span><span class="n">expiration</span><span class="o">=</span><span class="mi">3600</span><span class="p">),</span> <span class="s1">&#39;expiration&#39;</span><span class="p">:</span> <span class="mi">3600</span><span class="p">})</span>
</pre></div>
</div>
<p>由于这个路由也在蓝本中,所以添加到 before_request 处理程序上的认证机制也会用在这 个路由上。为了避免客户端使用旧令牌申请新令牌,要在视图函数中检查 g.token_used 变 量的值,如果使用令牌进行认证就拒绝请求。这个视图函数返回 JSON 格式的响应,其中 包含了过期时间为 1 小时的令牌。JSON 格式的响应也包含过期时间。</p>
</div>
<div class="section" id="json">
<h2>资源和JSON的序列化转换<a class="headerlink" href="#json" title="永久链接至标题">¶</a></h2>
<p>开发 Web 程序时,经常需要在资源的内部表示和 JSON 之间进行转换。JSON 是 HTTP 请求和响应使用的传输格式。</p>
<p>app/models.py:把文章转换成 JSON 格式的序列化字典</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Post</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">json_post</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;url&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_post&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;body&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">,</span>
            <span class="s1">&#39;body_html&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">body_html</span><span class="p">,</span>
            <span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="s1">&#39;author&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_user&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">author_id</span><span class="p">,</span>
                    <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;comments&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_post_comments&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="s1">&#39;comment_count&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">comments</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">json_post</span>
</pre></div>
</div>
</div></blockquote>
<p>url、author 和 comments 字段要分别返回各自资源的 URL,因此它们使用 url_for() 生 成,所调用的路由即将在 API 蓝本中定义。注意,所有 url_for() 方法都指定了参数 _ external=True,这么做是为了生成完整的 URL,而不是生成传统 Web 程序中经常使用的 相对 URL。</p>
<p>这段代码还说明表示资源时可以使用虚构的属性。comment_count 字段是博客文章的评论 数量,并不是模型的真实属性,它之所以包含在这个资源中是为了便于客户端使用。</p>
<p>User 模型的 to_json() 方法可以按照 Post 模型的方式定义,</p>
<p>app/models.py:把用户转换成 JSON 格式的序列化字典</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">json_user</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;url&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_post&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;username&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
            <span class="s1">&#39;member_since&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">member_since</span><span class="p">,</span>
            <span class="s1">&#39;last_seen&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_seen</span><span class="p">,</span>
            <span class="s1">&#39;posts&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_user_posts&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;followed_posts&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_user_followed_posts&#39;</span><span class="p">,</span>
                    <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;post_count&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">json_user</span>
</pre></div>
</div>
</div></blockquote>
<p>注意,为了保护隐私,这个方法中用户的某些属性没有加入响应,例如 email 和 role。这 段代码再次说明,提供给客户端的资源表示没必要和数据库模型的内部表示完全一致。</p>
<p>把 JSON 转换成模型时面临的问题是,客户端提供的数据可能无效、错误或者多余。</p>
<p>app/models.py:从 JSON 格式数据创建一篇博客文章:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">app.exceptions</span> <span class="k">import</span> <span class="n">ValidationError</span>
<span class="k">class</span> <span class="nc">Post</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">json_post</span><span class="p">):</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">json_post</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">body</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">body</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s1">&#39;post does not have a body&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Post</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">)</span>
</pre></div>
</div>
<p>如你所见,上述代码在实现过程中只选择使用 JSON 字典中的 body 属性,而把 body_html 属性忽略了,因为只要 body 属性的值发生变化,就会触发一个 SQLAlchemy 事件,自动 在服务器端渲染 Markdown。除非允许客户端倒填日期(这个程序并不提供此功能),否则 无需指定 timestamp 属性。由于客户端无权选择博客文章的作者,所以没有使用 author 字 段。author 字段唯一能使用的值是通过认证的用户。comments 和 comment_count 属性使用 数据库关系自动生成,因此其中没有创建模型所需的有用信息。最后,url 字段也被忽略 了,因为在这个实现中资源的 URL 由服务器指派,而不是客户端。</p>
<p>注意如何检查错误。如果没有 body 字段或者其值为空,from_json() 方法会抛出 ValidationError 异常。在这种情况下,抛出异常才是处理错误的正确方式,因为 from_json() 方法并没有掌握处理问题的足够信息,唯有把错误交给调用者,由上层代码处理这个错误。 ValidationError 类是 Python 中 ValueError 类的简单子类,</p>
<p>app/exceptions.py:ValidationError 异常:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ValidationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>现在,程序需要向客户端提供适当的响应以处理这个异常。为了避免在视图函数中编写捕 获异常的代码,我们可创建一个全局异常处理程序。</p>
<p>app/api_1_0/errors.py:API 中 ValidationError 异常的处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">validation_error</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bad_request</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>这里使用的 errorhandler 修饰器和注册 HTTP 状态码处理程序时使用的是同一个,只不过 此时接收的参数是 Exception 类,只要抛出了指定类的异常,就会调用被修饰的函数。注 意,这个修饰器从 API 蓝本中调用,所以只有当处理蓝本中的路由时抛出了异常才会调用 这个处理程序。</p>
<p>使用这个技术时,视图函数中得代码可以写得十分简洁明,而且无需检查错误:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/posts/&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">new_post</span><span class="p">():</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="p">)</span>
    <span class="n">post</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span>
    <span class="n">db</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>实现资源端点<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>现在我们需要实现用于处理不同资源的路由。GET 请求往往是最简单的,因为它们只返回
信息,无需修改信息。</p>
<p>app/api_1_0/posts.py:文章资源 GET 请求的处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/posts/&#39;</span><span class="p">)</span>
<span class="nd">@auth</span><span class="o">.</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">get_posts</span><span class="p">():</span>
    <span class="n">posts</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">({</span> <span class="s1">&#39;posts&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">post</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span> <span class="k">for</span> <span class="n">post</span> <span class="ow">in</span> <span class="n">posts</span><span class="p">]</span> <span class="p">})</span>

<span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/posts/&lt;int:id&gt;&#39;</span><span class="p">)</span>
<span class="nd">@auth</span><span class="o">.</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">get_post</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">get_or_404</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
</pre></div>
</div>
<p>第一个路由处理获取文章集合的请求。这个函数使用列表推导生成所有文章的 JSON 版本。 第二个路由返回单篇博客文章,如果在数据库中没找到指定 id 对应的文章,则返回 404 错误。</p>
<p>404 错误的处理程序在程序层定义,如果客户端请求 JSON 格式,就要返回 JSON 格式响应。如果要根据 Web 服务定制响应内容,也可在 API 蓝本中重 新定义 404 错误处理程序。</p>
<p>博客文章资源的 POST 请求处理程序把一篇新博客文章插入数据库。</p>
<p>app/api_1_0/posts.py:文章资源 POST 请求的处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/posts/&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="nd">@permission_required</span><span class="p">(</span><span class="n">Permission</span><span class="o">.</span><span class="n">WRITE_ARTICLES</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">new_post</span><span class="p">():</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="p">)</span>
    <span class="n">post</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span>
    <span class="n">db</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">to_json</span><span class="p">()),</span> <span class="mi">201</span><span class="p">,</span> \
        <span class="p">{</span><span class="s1">&#39;Location&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_post&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">post</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>
</pre></div>
</div>
<p>这个视图函数包含在 permission_required 修饰器(下面的示例中会定义)中,确保通过认证的用户有写博客文章的权限。得益于前面实现的错误处理程序,创建博客文章的过程 变得很直观。博客文章从 JSON 数据中创建,其作者就是通过认证的用户。这个模型写入 数据库之后,会返回 201 状态码,并把 Location 首部的值设为刚创建的这个资源的 URL。</p>
<p>注意,为便于客户端操作,响应的主体中包含了新建的资源。如此一来,客户端就无需在 创建资源后再立即发起一个 GET 请求以获取资源。</p>
<p>用来防止未授权用户创建新博客文章的 permission_required 修饰器和程序中使用的类似, 但会针对 API 蓝本进行自定义。</p>
<p>app/api_1_0/decorators.py:permission_required 修饰器:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">permission_required</span><span class="p">(</span><span class="n">permission</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span><span class="o">.</span><span class="n">can</span><span class="p">(</span><span class="n">permission</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">forbidden</span><span class="p">(</span><span class="s1">&#39;Insufficient permissions&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decorated_function</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>
</div>
<p>博客文章 PUT 请求的处理程序用来更新现有资源</p>
<p>app/api_1_0/posts.py:文章资源 PUT 请求的处理程序:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@api</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/posts/&lt;int:id&gt;&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;PUT&#39;</span><span class="p">])</span>
<span class="nd">@permission_required</span><span class="p">(</span><span class="n">Permission</span><span class="o">.</span><span class="n">WRITE_ARTICLES</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">edit_post</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Post</span><span class="o">.</span><span class="n">query</span><span class="o">.</span><span class="n">get_or_404</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span> <span class="o">!=</span> <span class="n">post</span><span class="o">.</span><span class="n">author</span> <span class="ow">and</span> \
        <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">current_user</span><span class="o">.</span><span class="n">can</span><span class="p">(</span><span class="n">Permission</span><span class="o">.</span><span class="n">ADMINISTER</span><span class="p">):</span> <span class="k">return</span> <span class="n">forbidden</span><span class="p">(</span><span class="s1">&#39;Insufficient permissions&#39;</span><span class="p">)</span>
    <span class="n">post</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">json</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="n">post</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jsonify</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
</pre></div>
</div>
<p>本例中要进行的权限检查更为复杂。修饰器用来检查用户是否有写博客文章的权限,但为 了确保用户能编辑博客文章,这个函数还要保证用户是文章的作者或者是管理员。这个检 查直接添加到视图函数中。如果这种检查要应用于多个视图函数,为避免代码重复,最好 的方法是为其创建修饰器。</p>
<p>因为程序不允许删除文章,所以没必要实现 DELETE 请求方法的处理程序。</p>
<p>用户资源和评论资源的处理程序实现方式类似。表 14-3 列出了这个程序要实现的资源。你 可到 GitHub 仓库(<a class="reference external" href="https://github.com/miguelgrinberg/flasky">https://github.com/miguelgrinberg/flasky</a>)中获取完整的实现,以便学习 研究</p>
</div>
<div class="section" id="id9">
<h2>分页大型资源集合<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>对大型资源集合来说,获取集合的 GET 请求消耗很大,而且难以管理。和 Web 程序一样,
Web 服务也可以对集合进行分页。</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">json_user</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;url&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_post&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;username&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
            <span class="s1">&#39;member_since&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">member_since</span><span class="p">,</span>
            <span class="s1">&#39;last_seen&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_seen</span><span class="p">,</span>
            <span class="s1">&#39;posts&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_user_posts&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;followed_posts&#39;</span><span class="p">:</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;api.get_user_followed_posts&#39;</span><span class="p">,</span>
                    <span class="nb">id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">_external</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
            <span class="s1">&#39;post_count&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">json_user</span>
</pre></div>
</div>
</div></blockquote>
<p>JSON 格式响应中的 posts 字段依旧包含各篇文章,但现在这只是完整集合的一部分。如 果资源有上一页和下一页,prev 和 next 字段分别表示上一页和下一页资源的 URL。count 是集合中博客文章的总数。</p>
<p>这种技术可应用于所有返回集合的路由。</p>
</div>
<div class="section" id="httpieweb">
<h2>使用HTTPie测试Web服务<a class="headerlink" href="#httpieweb" title="永久链接至标题">¶</a></h2>
<p>测试 Web 服务时必须使用 HTTP 客户端。最常使用的两个在命令行中测试 Web 服务的客
户端是 curl 和 HTTPie。后者的命令行更简洁,可读性也更高。
HTTPie 使用 pip 安装:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ pip install httpie
</pre></div>
</div>
<p>GET 请求可按照如下的方式发起:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ http --json --auth &lt;email&gt;:&lt;password&gt; GET
&gt; http://127.0.0.1:5000/api/v1.0/posts
HTTP/1.0 200 OK
Content-Length: 7018
Content-Type: application/json
Date: Sun, 22 Dec 2013 08:11:24 GMT
Server: Werkzeug/0.9.4 Python/2.7.3
{
&quot;posts&quot;: [
    ...
    ],
&quot;prev&quot;: null
&quot;next&quot;: &quot;http://127.0.0.1:5000/api/v1.0/posts/?page=2&quot;,
&quot;count&quot;: 150
}
</pre></div>
</div>
<p>注意响应中的分页链接。因为这是第一页,所以没有上一页,不过返回了获取下一页的 URL 和总数。</p>
<p>匿名用户可发送空邮件地址和密码以发起相同的请求:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ http --json --auth : GET http://127.0.0.1:5000/api/v1.0/posts/
</pre></div>
</div>
<p>下面这个命令发送 POST 请求以添加一篇新博客文章:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ http --auth &lt;email&gt;:&lt;password&gt; --json POST \
&gt; http://127.0.0.1:5000/api/v1.0/posts/ \
&gt; &quot;body=I&#39;m adding a post from the *command line*.&quot;
HTTP/1.0 201 CREATED
Content-Length: 360
Content-Type: application/json
Date: Sun, 22 Dec 2013 08:30:27 GMT
Location: http://127.0.0.1:5000/api/v1.0/posts/111
Server: Werkzeug/0.9.4 Python/2.7.3

{
    &quot;author&quot;: &quot;http://127.0.0.1:5000/api/v1.0/users/1&quot;,
    &quot;body&quot;: &quot;I&#39;m adding a post from the *command line*.&quot;,
    &quot;body_html&quot;: &quot;&lt;p&gt;I&#39;m adding a post from the &lt;em&gt;command line&lt;/em&gt;.&lt;/p&gt;&quot;,
    &quot;comments&quot;: &quot;http://127.0.0.1:5000/api/v1.0/posts/111/comments&quot;,
    &quot;comment_count&quot;: 0,
    &quot;timestamp&quot;: &quot;Sun, 22 Dec 2013 08:30:27 GMT&quot;,
    &quot;url&quot;: &quot;http://127.0.0.1:5000/api/v1.0/posts/111&quot;
}
</pre></div>
</div>
<p>要想使用认证令牌,可向 /api/v1.0/token 发送请求:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ http --auth &lt;email&gt;:&lt;password&gt; --json GET \
&gt; http://127.0.0.1:5000/api/v1.0/token
HTTP/1.0 200 OK
Content-Length: 162
Content-Type: application/json
Date: Sat, 04 Jan 2014 08:38:47 GMT
Server: Werkzeug/0.9.4 Python/3.3.3
{
    &quot;expiration&quot;: 3600,
    &quot;token&quot;: &quot;eyJpYXQiOjEzODg4MjQ3MjcsImV4cCI6MTM4ODgyODMyNywiYWxnIjoiSFMy...&quot;
}
</pre></div>
</div>
<p>在接下来的 1 小时中,这个令牌可用于访问 API,请求时要和空密码一起发送:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>(venv) $ http --json --auth eyJpYXQ...: GET http://127.0.0.1:5000/api/v1.0/posts/
</pre></div>
</div>
<p>令牌过期后,请求会返回 401 错误,表示需要获取新令牌。</p>
<p>祝贺你!我们在这一章结束了第二部分,至此,Flasky 的功能开发阶段就完全结束了。很 显然,下一步我们要部署 Flasky。在部署过程中,我们会遇到新的挑战,这就是第三部分 的主题</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">UserMixin</span><span class="p">,</span> <span class="n">db</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c1"># ...</span>
    <span class="n">avatar_hash</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># ...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">avatar_hash</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avatar_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">change_email</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="c1"># ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">email</span> <span class="o">=</span> <span class="n">new_email</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avatar_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
        <span class="n">db</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">gravatar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;identicon&#39;</span><span class="p">,</span> <span class="n">rating</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">is_secure</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://secure.gravatar.com/avatar&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;http://www.gravatar.com/avatar&#39;</span>
        <span class="nb">hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avatar_hash</span> <span class="ow">or</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
        <span class="k">return</span> <span class="s1">&#39;{url}/{hash}?s={size}&amp;d={default}&amp;r={rating}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="nb">hash</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">rating</span><span class="o">=</span><span class="n">rating</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>广告区——博主提供付费服务，欢迎各位大佬来撩 ，提供IT咨询回答服务。快没饭吃了，大佬土豪 施舍点吧。联系方式：微信QQ电话均为18977771077.</strong></p>
<dl class="docutils">
<dt>赞助扫码::</dt>
<dd><a class="first reference internal image-reference" href="../../../_images/apay.jpg"><img alt="../../../_images/apay.jpg" src="../../../_images/apay.jpg" style="width: 198px; height: 216px;" /></a>
<a class="last reference internal image-reference" href="../../../_images/pay_wechat.png"><img alt="../../../_images/pay_wechat.png" src="../../../_images/pay_wechat.png" style="width: 226px; height: 212px;" /></a>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ch15.html" class="btn btn-neutral float-right" title="第十五章：测试" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ch13.html" class="btn btn-neutral" title="第十三章：用户评论" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, anaf.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            LANGUAGE:'zh_CN',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>